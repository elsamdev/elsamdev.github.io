<html>

<head>
  <base href="https://example.com/pixel-art-generator/">
  <title>Pixel Art Generator with Color Reduction and Palette Change</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    .container {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    canvas {
      border: 1px solid #ccc;
      margin-bottom: 10px;
    }

    .button {
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 5px;
    }

    input[type="number"] {
      width: 50px;
      padding: 5px;
      margin-right: 10px;
    }

    #gridCanvas {
      position: absolute;
      pointer-events: none;
    }

    #paletteContainer {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 10px;
    }

    .palette-color {
      width: 30px;
      height: 30px;
      border: 1px solid #000;
      cursor: pointer;
    }

    .palette-color.selected {
      border: 2px solid #ff0000;
    }

    #customPaletteInput {
      margin-top: 10px;
    }

    #dropZone {
      border: 2px dashed #ccc;
      border-radius: 5px;
      padding: 20px;
      text-align: center;
      margin-bottom: 10px;
      cursor: pointer;
    }

    #dropZone.drag-over {
      background-color: #e0e0e0;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Pixel Art Generator</h1>
    <div id="dropZone">
      Drag and drop an image here or click to select a file
      <input type="file" id="fileInput" accept="image/*" style="display: none;">
    </div>
    <canvas id="outputCanvas"></canvas>
    <canvas id="gridCanvas"></canvas>
    <br>
    <label for="pixelSize">Pixel Size:</label>
    <input type="number" id="pixelSize" value="10" min="1" max="100">
    <button id="convertBtn" class="button">Convert to Pixel Art</button>
    <button id="copyJsonBtn" class="button">Copy JSON</button>
    <br>
    <label for="colorReduction">Color Reduction:</label>
    <input type="number" id="colorReduction" value="64" min="2" max="256">
    <button id="reduceColorsBtn" class="button">Reduce Colors</button>
    <br>
    <button id="changePaletteBtn" class="button">Change Color Palette</button>
    <div id="paletteContainer"></div>
    <input type="color" id="customPaletteInput">
    <button id="addCustomColorBtn" class="button">Add Custom Color</button>
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const outputCanvas = document.getElementById('outputCanvas');
    const gridCanvas = document.getElementById('gridCanvas');
    const ctx = outputCanvas.getContext('2d');
    const gridCtx = gridCanvas.getContext('2d');
    const convertBtn = document.getElementById('convertBtn');
    const copyJsonBtn = document.getElementById('copyJsonBtn');
    const pixelSizeInput = document.getElementById('pixelSize');
    const reduceColorsBtn = document.getElementById('reduceColorsBtn');
    const colorReductionInput = document.getElementById('colorReduction');
    const changePaletteBtn = document.getElementById('changePaletteBtn');
    const paletteContainer = document.getElementById('paletteContainer');
    const customPaletteInput = document.getElementById('customPaletteInput');
    const addCustomColorBtn = document.getElementById('addCustomColorBtn');

    let originalImage = null;
    let pixelData = [];
    let currentPalette = [];
    let selectedPaletteIndex = -1;

    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('drag-over');
    });
    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('drag-over');
    });
    dropZone.addEventListener('drop', handleFileDrop);
    fileInput.addEventListener('change', handleFileSelect);
    convertBtn.addEventListener('click', convertToPixelArt);
    copyJsonBtn.addEventListener('click', copyJsonToClipboard);
    reduceColorsBtn.addEventListener('click', reduceColors);
    changePaletteBtn.addEventListener('click', changePalette);
    addCustomColorBtn.addEventListener('click', addCustomColor);

    document.addEventListener('paste', handlePasteEvent);

    function handleFileDrop(e) {
      e.preventDefault();
      dropZone.classList.remove('drag-over');
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        loadImage(file);
      }
    }

    function handleFileSelect(e) {
      const file = e.target.files[0];
      if (file) {
        loadImage(file);
      }
    }

    function handlePasteEvent(e) {
      const items = e.clipboardData.items;
      for (let i = 0; i < items.length; i++) {
        if (items[i].type.indexOf('image') !== -1) {
          const blob = items[i].getAsFile();
          loadImage(blob);
          break;
        }
      }
    }

    function loadImage(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        originalImage = new Image();
        originalImage.onload = () => {
          outputCanvas.width = originalImage.width;
          outputCanvas.height = originalImage.height;
          ctx.drawImage(originalImage, 0, 0);
          gridCanvas.width = outputCanvas.width;
          gridCanvas.height = outputCanvas.height;
        };
        originalImage.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function convertToPixelArt() {
      if (!originalImage) return;

      const pixelSize = parseInt(pixelSizeInput.value);
      const width = Math.floor(originalImage.width / pixelSize);
      const height = Math.floor(originalImage.height / pixelSize);

      outputCanvas.width = width * pixelSize;
      outputCanvas.height = height * pixelSize;
      gridCanvas.width = outputCanvas.width;
      gridCanvas.height = outputCanvas.height;

      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(originalImage, 0, 0, width, height);
      ctx.drawImage(outputCanvas, 0, 0, width, height, 0, 0, outputCanvas.width, outputCanvas.height);

      updatePixelData();
      drawGrid();
      changePalette();
    }

    function updatePixelData() {
      const pixelSize = parseInt(pixelSizeInput.value);
      const width = outputCanvas.width / pixelSize;
      const height = outputCanvas.height / pixelSize;
      pixelData = [];

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const imageData = ctx.getImageData(x * pixelSize, y * pixelSize, 1, 1);
          const [r, g, b, a] = imageData.data;
          pixelData.push({
            x,
            y,
            color: `rgba(${r},${g},${b},${a / 255})`
          });
        }
      }
    }

    function drawGrid() {
      const pixelSize = parseInt(pixelSizeInput.value);
      gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
      gridCtx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
      gridCtx.lineWidth = 0.5;

      for (let x = 0; x <= gridCanvas.width; x += pixelSize) {
        gridCtx.beginPath();
        gridCtx.moveTo(x, 0);
        gridCtx.lineTo(x, gridCanvas.height);
        gridCtx.stroke();
      }

      for (let y = 0; y <= gridCanvas.height; y += pixelSize) {
        gridCtx.beginPath();
        gridCtx.moveTo(0, y);
        gridCtx.lineTo(gridCanvas.width, y);
        gridCtx.stroke();
      }
    }

    function copyJsonToClipboard() {
      const pixelSize = parseInt(pixelSizeInput.value);
      const jsonData = {
        width: outputCanvas.width / pixelSize,
        height: outputCanvas.height / pixelSize,
        pixels: pixelData
      };
      const jsonString = JSON.stringify(jsonData, null, 2);
      navigator.clipboard.writeText(jsonString).then(() => {
        alert('JSON copied to clipboard!');
      });
    }

    function reduceColors() {
      if (pixelData.length === 0) {
        alert('Please convert an image to pixel art first.');
        return;
      }

      const numColors = parseInt(colorReductionInput.value);
      const pixels = ctx.getImageData(0, 0, outputCanvas.width, outputCanvas.height);
      const data = pixels.data;

      // Use K-means clustering to reduce colors
      const colors = [];
      for (let i = 0; i < data.length; i += 4) {
        colors.push([data[i], data[i + 1], data[i + 2]]);
      }

      const kMeans = new KMeans(colors, numColors);
      const reducedColors = kMeans.run();

      for (let i = 0; i < data.length; i += 4) {
        const originalColor = [data[i], data[i + 1], data[i + 2]];
        const closestColor = findClosestColor(originalColor, reducedColors);
        data[i] = closestColor[0];
        data[i + 1] = closestColor[1];
        data[i + 2] = closestColor[2];
      }

      ctx.putImageData(pixels, 0, 0);
      updatePixelData();
      drawGrid();
      changePalette();
    }

    class KMeans {
      constructor(data, k) {
        this.data = data;
        this.k = k;
        this.centroids = [];
        this.assignments = [];
      }

      run(maxIterations = 100) {
        this.initializeCentroids();

        for (let i = 0; i < maxIterations; i++) {
          const oldCentroids = [...this.centroids];
          this.assignPointsToCentroids();
          this.updateCentroids();

          if (this.centroidsEqual(oldCentroids, this.centroids)) {
            break;
          }
        }

        return this.centroids;
      }

      initializeCentroids() {
        const uniqueColors = [...new Set(this.data.map(color => color.join(',')))].map(color => color.split(',').map(Number));
        this.centroids = uniqueColors.slice(0, this.k);
        while (this.centroids.length < this.k) {
          this.centroids.push(this.data[Math.floor(Math.random() * this.data.length)]);
        }
      }

      assignPointsToCentroids() {
        this.assignments = this.data.map(point => {
          const distances = this.centroids.map(centroid => this.distance(point, centroid));
          return distances.indexOf(Math.min(...distances));
        });
      }

      updateCentroids() {
        this.centroids = this.centroids.map((_, i) => {
          const assignedPoints = this.data.filter((_, j) => this.assignments[j] === i);
          return assignedPoints.length > 0
            ? assignedPoints.reduce((sum, point) => sum.map((v, i) => v + point[i]), [0, 0, 0]).map(v => v / assignedPoints.length)
            : this.data[Math.floor(Math.random() * this.data.length)];
        });
      }

      distance(a, b) {
        return Math.sqrt(a.reduce((sum, v, i) => sum + Math.pow(v - b[i], 2), 0));
      }

      centroidsEqual(a, b) {
        return a.every((centroid, i) => centroid.every((value, j) => Math.abs(value - b[i][j]) < 0.001));
      }
    }

    function findClosestColor(color, palette) {
      return palette.reduce((closest, current) => {
        const currentDistance = Math.sqrt(
          Math.pow(color[0] - current[0], 2) +
          Math.pow(color[1] - current[1], 2) +
          Math.pow(color[2] - current[2], 2)
        );
        return currentDistance < closest.distance ? { color: current, distance: currentDistance } : closest;
      }, { color: null, distance: Infinity }).color;
    }

    function changePalette() {
      if (pixelData.length === 0) {
        alert('Please convert an image to pixel art first.');
        return;
      }

      // Extract current colors from pixelData
      const uniqueColors = [...new Set(pixelData.map(pixel => pixel.color))];
      currentPalette = uniqueColors.map(color => {
        const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
        return match ? `#${parseInt(match[1]).toString(16).padStart(2, '0')}${parseInt(match[2]).toString(16).padStart(2, '0')}${parseInt(match[3]).toString(16).padStart(2, '0')}` : color;
      });

      updatePaletteDisplay();
    }

    function updatePaletteDisplay() {
      paletteContainer.innerHTML = '';
      currentPalette.forEach((color, index) => {
        const colorElement = document.createElement('div');
        colorElement.className = 'palette-color';
        colorElement.style.backgroundColor = color;
        colorElement.addEventListener('click', () => selectPaletteColor(index));
        paletteContainer.appendChild(colorElement);
      });
    }

    function selectPaletteColor(index) {
      const colorElements = paletteContainer.querySelectorAll('.palette-color');
      colorElements.forEach(el => el.classList.remove('selected'));
      colorElements[index].classList.add('selected');
      selectedPaletteIndex = index;
      customPaletteInput.value = currentPalette[index];
    }

    function addCustomColor() {
      const newColor = customPaletteInput.value;
      if (selectedPaletteIndex !== -1) {
        currentPalette[selectedPaletteIndex] = newColor;
      } else {
        currentPalette.push(newColor);
      }
      updatePaletteDisplay();
      applyNewPalette();
    }

    function applyNewPalette() {
      if (pixelData.length === 0) return;

      const imageData = ctx.getImageData(0, 0, outputCanvas.width, outputCanvas.height);
      const data = imageData.data;

      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const a = data[i + 3] / 255;

        const originalColor = `rgba(${r},${g},${b},${a})`;
        const originalIndex = pixelData.findIndex(pixel => pixel.color === originalColor);

        if (originalIndex !== -1) {
          const paletteIndex = originalIndex % currentPalette.length;
          const newColor = hexToRgb(currentPalette[paletteIndex]);

          data[i] = newColor.r;
          data[i + 1] = newColor.g;
          data[i + 2] = newColor.b;
        }
      }

      ctx.putImageData(imageData, 0, 0);
      updatePixelData();
      drawGrid();
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }
  </script>
</body>

</html>